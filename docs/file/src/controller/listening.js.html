<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/controller/listening.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <a data-ice="repoURL" href="https://github.com/npr/npr-one-api-js-sdk.git" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/index.js~NprOneSDK.html">NprOneSDK</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Config">Config</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Headers">Headers</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://github.com/jonnyreeves/js-logger">JsLogger</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Response">Response</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">controller</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/controller/authorization.js~Authorization.html">Authorization</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/controller/identity.js~Identity.html">Identity</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/controller/listening.js~Listening.html">Listening</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/controller/station-finder.js~StationFinder.html">StationFinder</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">error</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/error/api-error.js~ApiError.html">ApiError</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">model</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/model/access-token.js~AccessToken.html">AccessToken</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/model/action.js~Action.html">Action</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/model/collection-doc.js~CollectionDoc.html">CollectionDoc</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/model/device-code.js~DeviceCode.html">DeviceCode</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/model/rating.js~Rating.html">Rating</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/model/recommendation.js~Recommendation.html">Recommendation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/model/station.js~Station.html">Station</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/model/user.js~User.html">User</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-CollectionDocJSON">CollectionDocJSON</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Link">Link</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-FormFactorLink">FormFactorLink</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ImageLink">ImageLink</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RecommendationAttributes">RecommendationAttributes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StationAttributes">StationAttributes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StationBrandData">StationBrandData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StationEligibilityData">StationEligibilityData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StationNetwork">StationNetwork</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StationNetworkTierOne">StationNetworkTierOne</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StationNetworkTierThree">StationNetworkTierThree</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StationNetworkTierTwo">StationNetworkTierTwo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StationNewscastData">StationNewscastData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-UserAffiliation">UserAffiliation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-UserAttributes">UserAttributes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-UserCohort">UserCohort</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-UserOrganization">UserOrganization</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">util</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/util/fetch-util.js~FetchUtil.html">FetchUtil</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/util/validator.js~Validator.html">Validator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createRecommendations">createRecommendations</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Logger">Logger</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/controller/listening.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import NPROneSDK from &apos;./../index&apos;;
import createRecommendations from &apos;./../util/recommendation-creator&apos;;
import Action from &apos;./../model/action&apos;;
import Rating from &apos;./../model/rating&apos;;
import Logger from &apos;./../util/logger&apos;;
import FetchUtil from &apos;./../util/fetch-util&apos;;


/**
 * Encapsulates all of the logic for communication with the [Listening Service](http://dev.npr.org/api/#/listening)
 * in the NPR One API.
 *
 * Note that consumers should not be accessing this class directly but should instead use the provided pass-through
 * functions in the main {@link NprOneSDK} class.
 *
 * @example &lt;caption&gt;Implementing a rudimentary &apos;Explore&apos; view&lt;/caption&gt;
 * const nprOneSDK = new NprOneSDK();
 * nprOneSDK.config = { ... };
 * nprOneSDK.getRecommendationsFromChannel(&apos;recommended&apos;)
 *     .then((recommendations) =&gt; {
 *         // in a real app, the user would select a piece; here we&apos;ve simulated them selecting one at index 3
 *         const selectedRecommendationId = recommendations[3].attributes.uid;
 *         return nprOneSDK.queueRecommendationFromChannel(&apos;recommended&apos;, selectedRecommendationId);
 *      })
 *     .then(() =&gt; {
 *         nprOneSDK.getRecommendation(); // proceed to play the recommendation
 *     });
 */
export default class Listening {
    /**
     * Initializes the controller class with private variables needed later on.
     */
    constructor() {
        /** @type {Rating[]} Ratings which are queued to be sent to NPR
         * @private */
        this._queuedRatings = [];
        /** @type {Rating[]} Ratings which have already been sent, for debugging purposes
         * @private */
        this._sentRatings = [];
        /** @type {Array&lt;Recommendation&gt;} Unrated recommendations which represent the latest
         *  recommendations from the API, relies heavily upon numeric key/index
         * @private */
        this._flowRecommendations = [];
        /** @type {boolean} Flow fetches need to be synchronous
         * @private */
        this._flowFetchActive = false;
        /** @type {Promise&lt;Recommendation&gt;}
         * @private */
        this._flowPromise = null;
        /** @type {boolean} Whether ads are blocked by the browser.
         * @private */
        this._adsBlocked = false;
        /** @type {Object} Cached recommendations from channels other than the main flow channel of &apos;npr&apos;.
         * A key-value store where the key is the name of the channel and the value is an array of recommendations.
         * @private */
        this._channelRecommendations = {};

        // Ad-blocker detection, used when/if we encounter sponsorship in the flow
        fetch(&apos;http://adswizz.com&apos;, { mode: &apos;no-cors&apos; })
            .catch(() =&gt; {
                fetch(&apos;http://delivery-s3.adswizz.com&apos;, { mode: &apos;no-cors&apos; })
                    .catch(e =&gt; {
                        Logger.debug(&apos;Ads are blocked. &apos;, e);
                        this._adsBlocked = true;
                    });
            });
    }

    /**
     * Get a recommendation from NPR.
     *
     * Caution: the resulting recommendation may have been returned previously and must be checked
     * to ensure the same recommendation is not played twice.
     *
     * @param {string} [uid=&apos;&apos;]           Optional; a UID for a specific recommendation to play. In 99% of use cases, this is not needed.
     * @param {string} [channel=&apos;npr&apos;]    Optional; a channel to pull the recommendation from; the main flow channel of `npr` is used as the default. In 99% of use cases, this does not need to be changed.
     * @returns {Promise&lt;Recommendation&gt;}
     */
    getRecommendation(uid = &apos;&apos;, channel = &apos;npr&apos;) {
        this._flowPromise = this._advanceFlowRecommendations(channel, uid);

        return this._flowPromise;
    }

    /**
     * Return possible recommendations that may come next in the flow. Useful for
     * pre-caching audio and displaying upcoming recommendations.
     *
     * Recommendations returned are not guaranteed to always come next in the flow.
     *
     * @experimental
     * @param {string} [channel=&apos;npr&apos;]   A channel to pull the next recommendation from
     * @returns {Promise&lt;Array&lt;Recommendation&gt;&gt;}
     */
    getUpcomingFlowRecommendations(channel = &apos;npr&apos;) {
        if (this._flowRecommendations.length &gt; 0) {
            return Promise.resolve(this._flowRecommendations);
        }

        return this._getChannelRecommendations(channel);
    }

    /**
     * Makes a new API call to get a list of recommendations. This is NOT intended for regular piece-by-piece consumption;
     * this function is designed to be used for consumers implementing e.g. the Explore view from the NPR One apps,
     * where the client displays a list or grid of content, and the user can select a piece to listen to next.
     * It is hard-coded to use the &quot;recommended&quot; channel by default, although other channels can be used also. That said,
     * you should really never use this with channel &quot;npr&quot; (the main flow channel), as this is not how that content is
     * intended to be consumed.
     *
     * @param {string} [channel=&apos;recommended&apos;]   A non-flow (i.e. non-`npr`) channel to retrieve a list of recommendations from
     * @returns {Promise&lt;Array&lt;Recommendation&gt;&gt;}
     */
    getRecommendationsFromChannel(channel = &apos;recommended&apos;) {
        const _channel = (!channel || typeof channel !== &apos;string&apos;) ? &apos;recommended&apos; : channel;

        let prerequisitePromise = Promise.resolve(true);
        // Send any pending ratings we have first, just in case it impacts the results from the upcoming recommendations call
        if (this._queuedRatings.length &gt; 0) {
            prerequisitePromise = this._sendRatings();
        }

        return prerequisitePromise.then(this._getChannelRecommendations.bind(this, _channel, null))
            .then((recommendations) =&gt; {
                /* istanbul ignore if: defensive coding; should never really happen */
                if (!this._channelRecommendations) {
                    this._channelRecommendations = {};
                }
                this._channelRecommendations[_channel] = recommendations;
                return recommendations;
            });
    }

    /**
     * This synchronous method is intended to be used alongside {@link getRecommendationsFromChannel}.
     * Once you have a list of recommendations from a channel and an audio story has been selected to play, this method
     * ensures that the correct ratings (actions) will be sent and the flow of audio will continue appropriately with
     * the necessary API calls.
     * If the recommendation with the given UID can be found, it is delivered immediately to be played.
     * Importantly, this function also returns the selected recommendation on a subsequent call to getRecommendation
     * (assuming no other ratings are sent in between), so that the consumer can assume that the correct recommendation
     * will be played next.
     *
     * @param {string} channel   The channel used in the original call to `getRecommendationsFromChannel()`
     * @param {string} uid       The unique ID of the item to queue up for the user
     * @returns {Recommendation}
     * @throws {TypeError} If no valid channel or UID is passed in
     * @throws {Error} If no recommendations for this channel were previously cached, or if the UID was not found in that cached list
     */
    queueRecommendationFromChannel(channel, uid) {
        if (!channel || typeof channel !== &apos;string&apos;) {
            throw new TypeError(&apos;Must pass in a valid channel to queueRecommendationFromChannel()&apos;);
        }
        if (!uid || typeof uid !== &apos;string&apos;) {
            throw new TypeError(&apos;Must pass in a valid uid to queueRecommendationFromChannel()&apos;);
        }
        if (!(channel in this._channelRecommendations) ||
            this._channelRecommendations[channel].length === 0) {
            throw new Error(`Results from channel &quot;${channel}&quot; are not cached. ` +
                &apos;You must call getRecommendationsFromChannel() first.&apos;);
        }

        for (const recommendation of this._channelRecommendations[channel]) {
            if (recommendation.attributes.uid === uid) {
                /* istanbul ignore if: defensive coding; should never really happen */
                if (!this._flowRecommendations) {
                    this._flowRecommendations = [recommendation];
                } else {
                    this._flowRecommendations = [recommendation].concat(this._flowRecommendations);
                }
                return recommendation;
            }
        }
        throw new Error(`Unable to find story with uid ${uid} ` +
            `in cached list of recommendations from channel &quot;${channel}&quot;.`);
    }

    /**
     * Retrieves a user&apos;s history as an array of recommendation objects.
     *
     * @returns {Promise&lt;Array&lt;Recommendation&gt;&gt;}
     */
    getHistory() {
        const url = `${NPROneSDK.getServiceUrl(&apos;listening&apos;)}/history`;

        return FetchUtil.nprApiFetch(url).then(this._createRecommendations.bind(this));
    }


    /**
     * Resets the current flow for the user. Note that 99% of the time, clients will never have to do this (and it is
     * generally considered an undesirable user experience), but in a few rare cases it might be needed. The best example
     * is after calling `setUserStation()` if the current recommendation is of `type === &apos;stationId&apos;`; in this case,
     * resetting the flow may be necessary in order to make the user aware that they successfully changed their station.
     *
     * @example
     * let currentRecommendation = nprOneSDK.getRecommendation();
     * playAudio(currentRecommendation); // given a hypothetical playAudio() function in your app
     * ...
     * nprOneSDK.setUserStation(123)
     *     .then(() =&gt; {
     *         if (currentRecommendation.attributes.type === &apos;stationId&apos;) {
     *             nprOneSDK.resetFlow()
     *                 .then(() =&gt; {
     *                     currentRecommendation = nprOneSDK.getRecommendation();
     *                     playAudio(currentRecommendation);
     *                 });
     *         }
     *     });
     *
     * @returns {Promise}
     */
    resetFlow() {
        let prerequisitePromise = Promise.resolve(true);

        if (this._flowRecommendations &amp;&amp; this._flowRecommendations.length) {
            // Send any pending ratings we have first, just in case it impacts the results from the upcoming recommendations call
            if (this._queuedRatings.length &gt; 0) {
                prerequisitePromise = this._sendRatings(false);
            }

            return prerequisitePromise.then(() =&gt; {
                this._flowRecommendations = [];
                this._flowFetchActive = false;
                this._flowPromise = null;

                return true;
            });
        }

        return prerequisitePromise;
    }

    /**
     * Given a valid JSON recommendation object, the flow will advance as
     * normal from this recommendation. This method has been created for
     * a special case (Chromecast sharing) and is not intended for use
     * in a traditional SDK implementation.
     *
     * NOTE: this function will overwrite ALL existing flow
     * recommendations.
     *
     * @param {Object} json   Recommendation JSON Object (CDoc+JSON)
     * @returns {Recommendation}
     */
    resumeFlowFromRecommendation(json) {
        const recommendations = this._createRecommendations(json);
        this._flowRecommendations = recommendations;
        return this._flowRecommendations[0];
    }

    /**
     * Advances the flow (retrieves new recommendations from the API).
     *
     * @param {string} channel
     * @param {string} uid
     * @returns {Promise&lt;Array&lt;Recommendation&gt;&gt;}
     * @throws {Error} If there are no recommendations to return
     * @private
     */
    _advanceFlowRecommendations(channel, uid) {
        if (this._flowFetchActive) {
            Logger.debug(&apos;A listening service API request is already active, &apos; +
                &apos;returning existing promise if one exists.&apos;);

            /* istanbul ignore else: defensive coding */
            if (this._flowPromise) {
                return this._flowPromise;
            }
            /* istanbul ignore next: defensive coding */
            return Promise.reject(new Error(&apos;No recommendations available. Try again later.&apos;));
        }

        // if given a UID, we check first to see if we already have the recommendation cached
        if (uid &amp;&amp; !!this._flowRecommendations &amp;&amp; this._flowRecommendations.length &gt; 0) {
            let isRecommendationFound = false;
            this._flowRecommendations.forEach((recommendation, index) =&gt; {
                if (!isRecommendationFound &amp;&amp; recommendation.attributes.uid === uid) {
                    this._flowRecommendations = this._flowRecommendations.slice(index);
                    isRecommendationFound = true;
                }
            });
            if (isRecommendationFound) {
                Logger.debug(`Recommendation with UID ${uid} was already queued up. ` +
                    &apos;Returning the cached version instead of making a new API call.&apos;);
                return Promise.resolve(this._flowRecommendations[0]);
            }
        }

        this._flowFetchActive = true;
        return this._getFlowRecommendations(channel, uid)
            .then((recommendations) =&gt; {
                this._flowFetchActive = false;
                if (recommendations.length &lt;= 0) {
                    Logger.error(&apos;API returned no recommendations.&apos;);
                }
                this._flowRecommendations = this._filterIncomingRecommendations(recommendations);
                if (!this._flowRecommendations[0]) {
                    throw new Error(&apos;All recommendations exhausted!&apos;);
                }
                return this._flowRecommendations[0];
            })
            .catch(error =&gt; {
                this._flowFetchActive = false;
                throw error;
            });
    }

    /**
     * Provide any necessary filter to incoming recommendations if needed
     *
     * @param {Array&lt;Recommendation&gt;} recommendations
     * @private
     */
    _filterIncomingRecommendations(recommendations) {
        if (this._adsBlocked) {
            const unfilteredCount = recommendations.length;
            const _recommendations = recommendations.filter(rec =&gt; !rec.isSponsorship());
            const filteredCount = unfilteredCount - _recommendations.length;
            if (filteredCount &gt; 0) {
                Logger.debug(`Filtered ${filteredCount} ad(s).`);
            }
            return _recommendations;
        }

        return recommendations;
    }

    /**
     * Private method to facilitate communication of a rated recommendation.
     *
     * @param {Rating} rating
     * @private
     */
    _recordRating(rating) {
        if (this._queuedRatingsContainsRating(rating)) {
            return; // no need to take action for the same rating twice
        }

        Logger.debug(`Queued rating: ${rating}`);
        this._queuedRatings.push(rating);

        // Only one of these should ever fire, but this is easiest way to do the lookup
        for (const action of Action.getFlowAdvancingActions()) {
            if (rating.rating === action) {
                this.getRecommendation();
                break;
            }
        }
    }

    /**
     * Request for recommendations from NPR specifically for the flow as opposed to
     * other channels which will not change the current flow.
     *
     * @param {string} channel
     * @param {string} uid
     * @returns {Promise&lt;Array&lt;Recommendation&gt;&gt;}
     */
    _getFlowRecommendations(channel, uid) {
        for (const action of Action.getFlowAdvancingActions()) {
            if (this._queuedRatingsContainsAction(action)) {
                return this._sendRatings();
            }
        }

        if (!uid) {
            // Only perform the initial recommendation call if all flow recommendations are exhausted
            if (this._flowRecommendations.length &gt; 0) {
                return Promise.resolve(this._flowRecommendations);
            }
        }

        return this._getChannelRecommendations(channel, uid);
    }

    /**
     * @param {string} channel
     * @param {string} [uid=&apos;&apos;]
     * @returns {Promise&lt;Array&lt;Recommendation&gt;&gt;}
     * @private
     */
    _getChannelRecommendations(channel, uid = &apos;&apos;) {
        const _channel = (!channel || typeof channel !== &apos;string&apos;) ? &apos;npr&apos; : channel;

        let url = `${NPROneSDK.getServiceUrl(&apos;listening&apos;)}/recommendations?channel=${_channel}`;
        url += uid ? `&amp;sharedMediaId=${uid}` : &apos;&apos;;

        return FetchUtil.nprApiFetch(url).then(this._createRecommendations.bind(this));
    }

    /**
     * Create recommendation objects from collection doc
     *
     * @param {Object} json - collection doc
     * @returns {Array&lt;Recommendation&gt;}
     * @private
     */
    _createRecommendations(json) {
        const recommendations = createRecommendations(json);
        const recordRating = this._recordRating.bind(this);
        recommendations.map(rec =&gt; rec.setRatingReceivedCallback(recordRating));

        return recommendations;
    }

    /**
     * Send batched ratings
     *
     * @param {boolean} [recommendMore=true] - determines if additional recommendations should be returned
     * @returns {Promise&lt;Array&lt;Recommendation&gt;&gt;}
     * @private
     */
    _sendRatings(recommendMore = true) {
        /* istanbul ignore if: defensive coding */
        if (this._queuedRatings.length === 0) {
            Logger.error(&apos;Things have gone drastically wrong, this: &apos;, this);
            return Promise.reject(new Error(&apos;No queued ratings to send.&apos;));
        }

        let url = NPROneSDK.getServiceUrl(&apos;listening&apos;);
        url += `/ratings?recommend=${recommendMore.toString()}`;
        if (recommendMore) {
            const latestRating = this._queuedRatings.slice(-1).pop();
            if (latestRating._actionUrl &amp;&amp; latestRating.rating === Action.TAPTHRU) {
                url = latestRating._actionUrl;
            } else {
                url = latestRating._recommendationUrl;
            }
        }

        const ratingsToSend = [];
        this._queuedRatings.forEach(rating =&gt; {
            /* istanbul ignore else: defensive coding */
            if (!rating._hasSent) {
                ratingsToSend.push(rating);
            }
        });

        const options = {
            method: &apos;POST&apos;,
            body: JSON.stringify(ratingsToSend, Rating.privateMemberReplacer),
        };

        Logger.debug(&apos;Sending Ratings: &apos;, ratingsToSend.join(&apos;, &apos;));

        return FetchUtil.nprApiFetch(url, options)
            .then((json) =&gt; {
                // Loop through all queued ratings and mark as sent
                ratingsToSend.forEach((rating) =&gt; {
                    const _rating = rating;
                    _rating._hasSent = true;
                    this._sentRatings.push(_rating);
                    this._queuedRatings.splice(this._queuedRatings.indexOf(_rating), 1);
                });
                return this._createRecommendations(json);
            });
    }

    /**
     * Returns whether currently queued ratings contain a specific rating
     *
     * This is not a deep copy check and relies on mediaId &amp; rating string
     *
     * @param {Rating} rating
     * @returns {boolean}
     * @private
     */
    _queuedRatingsContainsRating(rating) {
        return this._queuedRatings.some(qr =&gt; qr.rating === rating.rating &amp;&amp; qr.mediaId === rating.mediaId);  // eslint-disable-line
    }

    /**
     * Returns whether the currently queued ratings contains a specific action
     *
     * @param {string} action
     * @returns {boolean}
     * @private
     */
    _queuedRatingsContainsAction(action) {
        return this._queuedRatings.some(qr =&gt; qr.rating === action);
    }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.8)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
